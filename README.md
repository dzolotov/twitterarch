# Эволюция архитектуры Twitter на Python

Этот проект демонстрирует пошаговую эволюцию архитектуры приложения социальной сети (аналог Twitter) через 6 различных реализаций, показывая как решать проблемы масштабируемости поэтапно.

## Обзор

Каждый шаг основывается на предыдущем, вводя новые архитектурные паттерны и оптимизации:

1. **Шаг 1: Базовая архитектура** - Простая синхронная реализация
2. **Шаг 2: Предвычисленные ленты** - Пре-компиляция лент для быстрого чтения
3. **Шаг 3: Асинхронная обработка** - RabbitMQ для асинхронных обновлений лент
4. **Шаг 4: Мульти-консьюмер** - Несколько воркеров с consistent hash маршрутизацией
5. **Шаг 5: Production-готовность** - Полный мониторинг и оптимизации
6. **Шаг 6: Кэшированная архитектура** - Redis кэширование с циклическими буферами

## Технологический стек

- **FastAPI**: Современный Python веб-фреймворк
- **SQLAlchemy**: ORM с поддержкой async
- **Citus (PostgreSQL 16)**: Распределённая база данных с автоматическим шардированием
- **RabbitMQ**: Брокер сообщений для асинхронной обработки
- **Redis**: Слой кэширования с циклическими буферами (Шаг 6)
- **Prometheus**: Сбор метрик
- **Grafana**: Визуализация метрик
- **StatsD**: Пользовательские метрики приложения
- **Docker**: Контейнеризация

## Быстрый старт

```bash
# Клонируйте репозиторий
cd python-twitter-arch

# Установите зависимости
pip install -r requirements.txt

# Запустите инфраструктуру
docker-compose up -d

# Запустите любой шаг (например: шаг 5)
cd step5_balanced
uvicorn main:app --reload --port 8005

# В отдельных терминалах запустите воркеры
python worker.py 0
python worker.py 1
python worker.py 2
python worker.py 3
```

## Эволюция архитектуры

Каждый шаг решает конкретные проблемы масштабируемости. Для подробного объяснения изменений между версиями см. [ARCHITECTURE_EVOLUTION_RU.md](ARCHITECTURE_EVOLUTION_RU.md).

### Шаг 1: Базовая синхронная архитектура
- Простой REST API с распределённой базой данных Citus
- JOIN запросы для генерации ленты (распределённые)
- Плохая производительность при большом количестве подписчиков
- Все операции блокирующие

### Шаг 2: Предвычисленные ленты
- Ленты хранятся в таблице `feed_items` (реляционной)
- Быстрое чтение, медленная запись
- Синхронное распространение при создании твита
- Лучшая производительность чтения

### Шаг 3: Асинхронная обработка
- RabbitMQ для разделения
- Неблокирующее создание твитов
- Фоновые обновления лент
- Обработка одним воркером

### Шаг 4: Мульти-консьюмер
- Несколько воркеров для параллелизма
- Consistent hash exchange
- Сообщения для каждого подписчика
- Горизонтальное масштабирование

### Шаг 5: Production-готовность
- Полные метрики и мониторинг
- Оптимизированная маршрутизация (hash: 20)
- Пакетная обработка
- Корректное завершение работы
- Ограничения ресурсов

### Шаг 6: Кэшированная архитектура
- Redis кэширование с циклическими буферами
- Кэширование горячих лент
- Дедупликация сообщений
- Стратегии прогрева кэша
- Улучшение производительности в 10 раз

## Ключевые архитектурные решения

1. **Распределённая база с самого начала**: Citus обеспечивает горизонтальное масштабирование с Шага 1
2. **Только реляционное хранение**: Все данные хранятся в PostgreSQL таблицах, без JSON колонок
3. **Таблица элементов ленты**: Каждый твит в ленте пользователя - отдельная строка
4. **Колокация данных**: Связанные данные (пользователь, твиты, ленты) на одном шарде
5. **Consistent Hashing**: Равномерное распределение работы между воркерами
6. **Идемпотентные операции**: Безопасное повторение неуспешных сообщений
7. **Метрики в приоритете**: Встроенный комплексный мониторинг

## Характеристики производительности

| Шаг | Создание твита | Чтение ленты | Масштабируемость |
|-----|---------------|--------------|------------------|
| 1   | Быстро        | Медленно     | Плохая           |
| 2   | Медленно      | Быстро       | Ограниченная     |
| 3   | Быстро        | Быстро       | Лучше            |
| 4   | Быстро        | Быстро       | Хорошая          |
| 5   | Быстро        | Быстро       | Отличная         |
| 6   | Быстро        | Очень быстро | Отличная         |

## API эндпоинты

Все шаги используют одинаковую структуру API:

- `POST /api/users/` - Создать пользователя
- `GET /api/users/{id}` - Получить пользователя
- `POST /api/tweets/` - Создать твит
- `GET /api/tweets/{id}` - Получить твит
- `GET /api/feed/` - Получить ленту пользователя
- `POST /api/subscriptions/follow` - Подписаться на пользователя
- `DELETE /api/subscriptions/unfollow/{id}` - Отписаться

Шаг 5 добавляет:
- `GET /metrics` - Метрики Prometheus
- `GET /health` - Проверка здоровья

Шаг 6 добавляет:
- `GET /cache/stats` - Статистика кэша

## Мониторинг (Шаг 5)

Доступ к инструментам мониторинга:
- Метрики Prometheus: http://localhost:8005/metrics
- Дашборды Grafana: http://localhost:3000
- Управление RabbitMQ: http://localhost:15672

## Тестирование

Каждый шаг включает примеры тестирования производительности в своём README. Общий паттерн:

```bash
# Создание пользователей (2000 для демонстрации эффекта)
for i in {1..2000}; do
  curl -X POST http://localhost:800X/api/users/ \
    -H "Content-Type: application/json" \
    -d "{\"username\": \"user$i\", \"email\": \"user$i@example.com\"}"
done

# Создание подписчиков и тестирование
# См. подробности в README отдельных шагов
```

**Примечание**: Во всех демо-скриптах используется 2000 пользователей для наглядной демонстрации эффекта от оптимизаций. При такой нагрузке разница в производительности между шагами становится очень заметной.

## Запуск демонстраций

### Демонстрация отдельных шагов
Каждый шаг имеет свой собственный скрипт `run_demo.sh` с docker-compose:
```bash
cd step1_basic
./run_demo.sh
```

### Запуск всех демонстраций
```bash
./run_all_demos.sh      # Запустить все шаги последовательно
./run_all_demos.sh 3    # Запустить только шаг 3
```

### Сравнение производительности
```bash
./performance_comparison.sh  # Сравнить все шаги с одинаковой нагрузкой
```

## Извлечённые уроки

1. **Начинайте с распределённости**: Citus с самого начала избавляет от болезненных миграций
2. **Компромиссы**: Быстрое чтение vs быстрая запись
3. **Асинхронность - ключ**: Разделение улучшает отзывчивость
4. **Горизонтальное масштабирование**: Несколько воркеров справляются с нагрузкой
5. **Локальность данных**: Колокация драматически улучшает производительность
6. **Мониторинг**: Необходим для production систем
7. **Оптимизация**: Небольшие изменения (routing key) имеют значение
8. **Кэширование**: Драматические улучшения для горячих данных

## Следующие шаги

Возможные расширения:
- Реализовать алгоритмы смешивания временных линий
- Добавить обновления в реальном времени (WebSockets)
- Реализовать рекомендации пользователей
- Добавить обработку медиа
- Реализовать трендовые темы
- Добавить больше Citus воркеров для ещё большего масштаба
- Реализовать межцентровую репликацию

## Лицензия

Это образовательный проект, демонстрирующий архитектурные паттерны.